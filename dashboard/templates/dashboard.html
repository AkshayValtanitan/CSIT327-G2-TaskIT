{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weekly Calendar</title>
    <link rel="stylesheet" href="{% static 'login/css/dashboard.css' %}?v={% now 'U' %}">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/intro.js/minified/introjs.min.css">
    <script src="https://cdn.jsdelivr.net/npm/intro.js/minified/intro.min.js"></script>
</head>
<body class="{% if request.session.theme == 'dark' %}dark-mode{% endif %}">
    <div class="sidebar"
        data-step="1" 
        data-intro="This is your sidebar. You can navigate your dashboard here.">
        <h2>Dashboard</h2>

        <button onclick="startTutorial()" class="tutbtn">Start Tutorial</button>

        <div
            data-step="2" 
            data-intro="Click here to add a new task.">
            <button id="openQuickAdd" class="button addtask">Add Task</button>
        </div>
        
        <button id="theme-toggle" class="themebtn">Toggle Theme</button>

        <form method="get" action="{% url 'dashboard' %}">
            <button type="submit">Dashboard</button>
        </form>
        <form method="get" action="{% url 'settings' %}">
            <button type="submit">Settings</button>
        </form>

        <div class="sidebar-bottom">
            <form action="{% url 'logout' %}" method="POST">
                {% csrf_token %}
                <button type="submit" id="logoutButton">Log Out</button>
            </form>
        </div>
        
    </div>

    <div id="welcomeModal" class="welcome-modal" aria-hidden="true" role="dialog">
        <div class="welcome-modal-content">
            <h2>Welcome!</h2>
        </div>
    </div>

    <div class="main">
        <div class="dashboard-toolbar">
            <div>
                <h1>Weekly Overview</h1>
                <p id="analyticsStatus" class="analytics-status" role="status" aria-live="polite">Preparing data…</p>
            </div>
            <div class="toolbar-actions">
                <button id="refreshDashboard" class="btn-secondary compact" type="button">Refresh</button>
            </div>
        </div>
        <div id="weeklySummary" class="weekly-summary">
            <div class="weekly-report" data-step="3" data-intro="Track how your week is progressing.">
                <div class="summary-week">
                    <div class="summary-card">
                        <p class="summary-label">Week Range</p>
                        <p id="ws-range" class="summary-value">—</p>
                    </div>
                    <div class="summary-card">
                        <p class="summary-label">Total</p>
                        <p id="ws-total" class="summary-value emphasis">0</p>
                    </div>
                    <div class="summary-card success">
                        <p class="summary-label">Completed</p>
                        <p id="ws-completed" class="summary-value emphasis">0</p>
                    </div>
                    <div class="summary-card warning">
                        <p class="summary-label">Pending</p>
                        <p id="ws-pending" class="summary-value emphasis">0</p>
                    </div>
                </div>
                <div id="ws-warning" class="summary-alert hidden" role="alert">
                    Heavy load detected. Consider completing or rescheduling some tasks.
                </div>

                <div id="lists" class="task-lists">
                    <div class="task-categories unfinished">
                        <h3>Unfinished</h3>
                        <ul id="unfinishedList"></ul>
                    </div>
                    <div class="task-categories completed">
                        <h3>Completed</h3>
                        <ul id="completedList"></ul>
                    </div>
                    <div class="task-categories overdue" id="overdue">
                        <h3>Overdue</h3>
                        <ul id="overdueTasks"></ul>
                    </div>
                </div>
            </div>

            <div class="circleNlabels">
                <div class="percentage-container">
                    <b><p>Completion Statistics</p></b>

                    <div class="circle-container">
                        <div class="circle" id="completion-circle">0%</div>
                        <div class="circle small"></div>
                    </div>
                </div>
                <div class="percent-labels">
                        <p><span class="color-box green"></span> Completed: <span id="completed-pct">0%</span></p>
                        <p><span class="color-box red"></span> Overdue: <span id="overdue-pct">0%</span></p>
                        <p><span class="color-box yellow"></span> Unfinished: <span id="unfinished-pct">0%</span></p>
                    </div>
            </div>
        </div>
        
        <div class="calendar-box"
                    data-step="5" 
                    data-intro="After filling up the form you can press Add Task">
            <div class="calendar-header">
                <h1 class="month-year" id="monthYear"></h1>
            </div>
            <div class="calendar-container"
                    data-step="4" 
                    data-intro="Once finished they will be added to the calendar!">
                <div class="calendar-grid" id="calendarGrid"></div>
            </div>
        </div>
        
    </div>

    <!-- Quick Add Modal -->
    <div id="quickAddModal" class="modal hidden" aria-hidden="true" role="dialog" aria-labelledby="qaTitle">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="qaTitle">Quick Add Task</h2>
                <button id="closeQuickAdd" class="icon-btn" aria-label="Close">✕</button>
            </div>
            <form id="quickAddForm" novalidate>
                <div class="form-grid">
                    <label>
                        <span>Title</span>
                        <input type="text" id="taskTitle" name="title" placeholder="e.g., Math assignment" required>
                    </label>
                    <label>
                        <span>Date</span>
                        <input type="date" id="taskDate" name="date" required>
                    </label>
                    <label>
                        <span>Start Hour</span>
                        <select id="taskHour" name="hour" required></select>
                    </label>
                    <label>
                        <span>Color</span>
                        <input type="color" id="taskColor" name="color" value="#2e7d32">
                    </label>
                    <label>
                        <span>Priority</span>
                        <select id="taskPriority" name="priority">
                            <option value="Low">Low</option>
                            <option value="Medium" selected>Medium</option>
                            <option value="High">High</option>
                        </select>
                    </label>
                    <label>
                        <span>Status</span>
                        <select id="taskStatus" name="status">
                            <option value="Pending" selected>Unfinished</option>
                            <option value="Completed">Completed</option>
                        </select>
                    </label>
                </div>
                <label>
                    <span>Description</span>
                    <textarea id="taskDescription" name="description" rows="3" placeholder="Optional notes"></textarea>
                </label>
                <div id="formError" class="form-error" role="alert"></div>
                <div class="modal-actions">
                    <button type="button" id="cancelQuickAdd" class="btn-secondary">Cancel</button>
                    <button type="submit" class="btn-primary">Add Task</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        const calendarGrid = document.getElementById("calendarGrid");
        const monthYear = document.getElementById("monthYear");
        const openQuickAdd = document.getElementById("openQuickAdd");
        const quickAddModal = document.getElementById("quickAddModal");
        const closeQuickAdd = document.getElementById("closeQuickAdd");
        const cancelQuickAdd = document.getElementById("cancelQuickAdd");
        const quickAddForm = document.getElementById("quickAddForm");
        const taskTitle = document.getElementById("taskTitle");
        const taskDate = document.getElementById("taskDate");
        const taskHour = document.getElementById("taskHour");
        const taskColor = document.getElementById("taskColor");
        const taskDescription = document.getElementById("taskDescription");
        const taskPriorityField = document.getElementById("taskPriority");
        const taskStatusField = document.getElementById("taskStatus");
        const formError = document.getElementById("formError");
        const toggle = document.getElementById("theme-toggle");
        const body = document.body;
        const wsRange = document.getElementById("ws-range");
        const wsTotal = document.getElementById("ws-total");
        const wsCompleted = document.getElementById("ws-completed");
        const wsPending = document.getElementById("ws-pending");
        const overdueList = document.getElementById("overdueTasks");
        const analyticsStatus = document.getElementById("analyticsStatus");
        const refreshDashboardBtn = document.getElementById("refreshDashboard");
        const wsWarningBanner = document.getElementById("ws-warning");
        const completionCircle = document.getElementById("completion-circle");
        const completedPctLabel = document.getElementById("completed-pct");
        const overduePctLabel = document.getElementById("overdue-pct");
        const unfinishedPctLabel = document.getElementById("unfinished-pct");
        const listsContainer = document.getElementById("lists");
        const calendarContainer = document.querySelector(".calendar-container");
        let tasksCache = [];
        let summaryCache = null;
        let completionCache = null;
        let isRefreshing = false;
        const cellLookup = new Map();
        let editingTaskId = null;

        const now = new Date();
        const currentDate = now.getDate();
        // const currentDay = now.getDay(); // 0 = Sunday
        const currentHour = now.getHours();

        const monthNames = [
            "January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];

        // show current month & year
        monthYear.textContent = `${monthNames[now.getMonth()]} ${now.getFullYear()}`;

        // const daysOfWeek = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        const daysInMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0).getDate();
        const hours = Array.from({ length: 24 }, (_, i) => {
            const hour = i % 12 || 12;
            const ampm = i < 12 ? "AM" : "PM";
            return `${hour} ${ampm}`;
        });
        const buildCellKey = (day, hour) => `${day}-${hour}`;
        const PRIORITY_OPTIONS = ['Low', 'Medium', 'High'];
        const STATUS_OPTIONS = ['Pending', 'Completed'];

        function normalizeSelection(value, options, fallback) {
            const comparison = (value || '').toString().toLowerCase();
            const match = options.find(opt => opt.toLowerCase() === comparison);
            return match || fallback;
        }

        function getTaskColor(dateStr, status) {
            const today = new Date();
            const taskDate = new Date(dateStr);
            const normalizedStatus = (status || '').toLowerCase();

            if (normalizedStatus === 'completed') return 'task-completed'; // grey
            const diffTime = taskDate.getTime() - today.getTime();
            const diffDays = diffTime / (1000 * 60 * 60 * 24);

            if (diffDays >= 7) return 'task-green';      // 7 days or more
            if (diffDays >= 2) return 'task-yellow';     // between 2 and 7 days
            if (diffDays < 2) return 'task-red';         // less than 2 days

            return 'task-default';
        }

        function setAnalyticsStatus(message, variant = "neutral") {
            if (!analyticsStatus) return;
            analyticsStatus.textContent = message;
            analyticsStatus.dataset.variant = variant;
        }

        function toggleRefresh(disabled) {
            if (!refreshDashboardBtn) return;
            refreshDashboardBtn.disabled = disabled;
            refreshDashboardBtn.setAttribute("aria-busy", disabled ? "true" : "false");
        }

        window.addEventListener('load', () => {
            const modal = document.getElementById('welcomeModal');

            if (!localStorage.getItem("welcomeShown")) {
                modal.classList.add('show');

                setTimeout(() => {
                    modal.classList.remove('show');
                    setTimeout(() => {
                        modal.style.display = 'none';
                    }, 500); 
                }, 2000); 
                
                localStorage.setItem("welcomeShown", "true");
            }
        });

        document.querySelector('#logoutButton').addEventListener('click', () => {
            localStorage.removeItem("welcomeShown");
        });

        if (localStorage.getItem("theme") === "dark") {
            body.classList.add("dark-mode");
        }

        toggle.addEventListener("click", () => {
            body.classList.toggle("dark-mode");
            const theme = body.classList.contains("dark-mode") ? "dark" : "light";
            localStorage.setItem("theme", theme);
        });

        window.addEventListener('load', () => {
            if (!localStorage.getItem("tutorialShown")) {
                introJs().start();
                localStorage.setItem("tutorialShown", "true");
            }
        });

        function startTutorial() {
            introJs().start();
        }

        window.addEventListener('load', () => {
            const currentDateCell = document.querySelector(`.cell.current-day.current-time`);

            if (currentDateCell && calendarContainer) {
                // Calculate the offset to center the current cell
                const offsetLeft = currentDateCell.offsetLeft - calendarContainer.offsetWidth / 2 + currentDateCell.offsetWidth / 2;
                const offsetTop = currentDateCell.offsetTop - calendarContainer.offsetHeight / 2 + currentDateCell.offsetHeight / 2;

                calendarContainer.scrollTo({
                    left: offsetLeft,
                    top: offsetTop,
                    behavior: 'smooth' // optional for smooth scrolling
                });
            }
        });




        // populate hour select in modal
        function populateHourSelect() {
            taskHour.innerHTML = "";
            for (let i = 0; i < 24; i++) {
                const hour = i % 12 || 12;
                const ampm = i < 12 ? "AM" : "PM";
                const opt = document.createElement("option");
                opt.value = String(i);
                opt.textContent = `${hour} ${ampm}`;
                if (i === currentHour) opt.selected = true;
                taskHour.appendChild(opt);
            }
        }

        // create header row, the mondays, tuesdays etc.
        const headerRow = document.createElement("div");
            headerRow.className = "header-row";
            headerRow.innerHTML = `<div class="timecol-corner"></div>` +
            Array.from({ length: daysInMonth }, (_, i) => {
                const day = i + 1;
                const dayName = new Date(now.getFullYear(), now.getMonth(), day)
                    .toLocaleString('default', { weekday: 'short' });
                return `
                    <div class="day-header ${day === currentDate ? 'current-daycol' : ''}">
                        <div>${dayName}&nbsp;</div>
                        <div><b>${day}</b></div>
                    </div>
                `;
            }).join("");
        calendarGrid.appendChild(headerRow);

        // create hour rows
        hours.forEach((h, hourIndex) => {
            const row = document.createElement("div");
            row.className = "hour-row";

            const timeCell = document.createElement("div");
            timeCell.className = "time-col";
            timeCell.textContent = h;
            row.appendChild(timeCell);

            for (let day = 1; day <= daysInMonth; day++) {
                const cell = document.createElement("div");
                cell.className = "cell";
                cell.dataset.day = String(day);
                cell.dataset.hour = String(hourIndex);
                cellLookup.set(buildCellKey(day, hourIndex), cell);

                // highlight current day & hour
                if (day === currentDate) {
                    cell.classList.add("current-day");
                }


                if (day === currentDate && hourIndex === currentHour) {
                    cell.classList.add("current-time");
                }

                row.appendChild(cell);
            }

            calendarGrid.appendChild(row);
        });

        // CSRF helper (for Django POST, PATCH, DELETE)
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let cookie of cookies) {
                    const trimmed = cookie.trim();
                    if (trimmed.startsWith(name + '=')) {
                        cookieValue = decodeURIComponent(trimmed.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        const csrftoken = getCookie('csrftoken');

        // API helpers (Supabase via Django endpoints)
        const API_BASE = '/api/tasks/';
        async function apiGetTasks(year, month) {
            const params = new URLSearchParams({ year: String(year), month: String(month) });
            const res = await fetch(`${API_BASE}?${params.toString()}`, { credentials: 'same-origin' });
            if (!res.ok) throw new Error('Failed to fetch tasks');
            const data = await res.json();
            return data.tasks || [];
        }
        async function apiCreateTask(task) {
            const res = await fetch(API_BASE, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrftoken
                 },
                credentials: 'same-origin',
                body: JSON.stringify(task)
            });
            const data = await res.json();
            if (!res.ok) throw new Error(data.error || 'Failed to create task');
            return data.tasks;
        }
        async function apiPatchTask(id, patch) {
            const res = await fetch(`/api/tasks/${id}/`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrftoken
                },
                credentials: 'same-origin',
                body: JSON.stringify(patch)
            });
            if (!res.ok) throw new Error('Failed to update');
            return res.json();
        }
        async function apiWeeklySummary() {
            const res = await fetch('/api/tasks/summary/', { credentials: 'same-origin' });
            if (!res.ok) throw new Error('Failed to fetch weekly summary');
            return res.json();
        }
        async function apiWeeklyCompletionStats() {
            const res = await fetch('/api/tasks/weekly_completion_stats/', { credentials: 'same-origin' });
            if (!res.ok) throw new Error('Failed to fetch completion stats');
            return res.json();
        }

        // Render tasks onto calendar
        async function renderTasks(tasksOverride = null) {
            document.querySelectorAll('.event-pill').forEach(el => el.remove());
            const year = now.getFullYear();
            const monthIndex = now.getMonth();
            let tasks = tasksOverride;

            if (!tasks) {
                try {
                    tasks = await apiGetTasks(year, monthIndex + 1);
            } catch (e) {
                console.error(e);
                    setAnalyticsStatus('Failed to fetch tasks', 'error');
                    return;
                }
            }

            const priorityRank = { high: 0, medium: 1, low: 2 };
            const sortedTasks = tasks.slice().sort((a, b) => {
                const aPriority = priorityRank[(a.priority || 'medium').toLowerCase()] ?? 1;
                const bPriority = priorityRank[(b.priority || 'medium').toLowerCase()] ?? 1;
                if (aPriority !== bPriority) return aPriority - bPriority;
                const ad = new Date(a.date);
                const bd = new Date(b.date);
                if (ad.getTime() !== bd.getTime()) return ad - bd;
                return (Number(a.hour) || 0) - (Number(b.hour) || 0);
            });

            const unfinished = document.getElementById('unfinishedList');
            const completed = document.getElementById('completedList');

            if (unfinished) unfinished.innerHTML = '';
            if (completed) completed.innerHTML = '';
            if (overdueList) overdueList.innerHTML = '';

            const unfinishedFragment = document.createDocumentFragment();
            const completedFragment = document.createDocumentFragment();
            const overdueFragment = document.createDocumentFragment();
                const today = new Date();

            sortedTasks.forEach(task => {
                const d = new Date(task.date);
                if (d.getFullYear() !== year || d.getMonth() !== monthIndex) return;

                const day = d.getDate();
                const hourIndex = Number(task.hour ?? 0);
                const cell = cellLookup.get(buildCellKey(day, hourIndex));
                if (!cell) return;

                const displayTitle = task.title || task.task_name || '';
                const normalizedStatus = (task.status || 'Pending').toLowerCase();
                const displayPriority = normalizeSelection(task.priority, PRIORITY_OPTIONS, 'Medium');
                // const pill = document.createElement('div');
                // pill.className = 'event-pill';
                // pill.textContent = displayTitle;
                // pill.style.backgroundColor = task.color || '#2e7d32';
                // pill.title = task.description || '';
                // const taskId = task.id || task.task_id;
                // pill.dataset.id = taskId;
                // pill.addEventListener('click', () => openEditModal({ ...task, title: displayTitle, id: taskId }));
                // cell.appendChild(pill);
                const colorClass = getTaskColor(task.date, normalizedStatus);

                const pill = document.createElement('div');
                pill.className = `event-pill ${colorClass}`;
                pill.textContent = displayTitle;
                pill.title = task.description || '';

                const taskId = task.id || task.task_id;
                pill.dataset.id = taskId;

                pill.addEventListener('click', () => 
                    openEditModal({ ...task, title: displayTitle, id: taskId })
                );

                cell.appendChild(pill);

                const li = document.createElement('li');
                const hourLabel = hours[hourIndex] || `${hourIndex}:00`;
                li.textContent = `${displayTitle} — ${displayPriority} — ${d.toLocaleDateString()} ${hourLabel}`;
                li.style.cursor = 'pointer';
                li.dataset.id = taskId;
                li.setAttribute('role', 'button');
                li.addEventListener('click', () => openEditModal({ ...task, title: displayTitle, id: taskId }));
                li.addEventListener('keydown', (evt) => {
                    if (evt.key === 'Enter' || evt.key === ' ') {
                        evt.preventDefault();
                        openEditModal({ ...task, title: displayTitle, id: taskId });
                    }
                });
                li.setAttribute('tabindex', '0');

                let bgColor = '#cfd8dc';
                switch (displayPriority.toLowerCase()) {
                    case 'high':
                        bgColor = '#ff6b6b';
                        break;
                    case 'medium':
                        bgColor = '#fbc02d';
                        break;
                    case 'low':
                        bgColor = '#81c784';
                        break;
                }
                li.style.backgroundColor = bgColor;
                li.style.padding = '6px 10px';
                li.style.borderRadius = '6px';
                li.style.marginBottom = '4px';
                li.style.color = '#111';

                const isCompleted = normalizedStatus === 'completed';
                const isOverdue = d < today && !isCompleted;

                if (isCompleted) {
                    li.classList.add('list-item-completed');
                    completedFragment.appendChild(li);
                } else if (isOverdue) {
                    li.classList.add('list-item-overdue');
                    overdueFragment.appendChild(li);
                } else {
                    unfinishedFragment.appendChild(li);
                }
            });

            if (unfinished) unfinished.appendChild(unfinishedFragment);
            if (completed) completed.appendChild(completedFragment);
            if (overdueList) overdueList.appendChild(overdueFragment);
        }

        // Modal controls
        function openModal() {
            populateHourSelect();
            taskDate.value = new Date().toISOString().slice(0, 10);
            formError.textContent = "";
            quickAddModal.classList.remove('hidden');
            quickAddModal.setAttribute('aria-hidden', 'false');
            taskTitle.focus();

            editingTaskId = null;

            const existingDelete = document.getElementById('deleteTaskBtn');
            if (existingDelete) existingDelete.remove();
        }
        function closeModal() {
            quickAddModal.classList.add('hidden');
            quickAddModal.setAttribute('aria-hidden', 'true');
            quickAddForm.reset();
            formError.textContent = "";

            editingTaskId = null;

            const db = document.getElementById('deleteTaskBtn');
            if (db) db.remove();
        }

        openQuickAdd.addEventListener('click', openModal);
        closeQuickAdd.addEventListener('click', closeModal);
        cancelQuickAdd.addEventListener('click', closeModal);
        window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeModal(); });

        // Edit/Delete modal (simple reuse of quick add modal)
        async function openEditModal(task) {
            populateHourSelect();
            taskTitle.value = task.title || '';
            const normalizedDate = task.date ? String(task.date).slice(0, 10) : new Date().toISOString().slice(0, 10);
            taskDate.value = normalizedDate;
            taskHour.value = String(task.hour ?? currentHour);
            taskColor.value = task.color || '#2e7d32';
            taskDescription.value = task.description || '';
            taskPriorityField.value = normalizeSelection(task.priority, PRIORITY_OPTIONS, 'Medium');
            taskStatusField.value = normalizeSelection(task.status, STATUS_OPTIONS, 'Pending');
            formError.textContent = "";
            quickAddModal.classList.remove('hidden');
            quickAddModal.setAttribute('aria-hidden', 'false');

            editingTaskId = task.id || task.task_id;

            const actions = document.querySelector('.modal-actions');
            let deleteBtn = document.getElementById('deleteTaskBtn');
            if (!deleteBtn) {
                deleteBtn = document.createElement('button');
                deleteBtn.id = 'deleteTaskBtn';
                deleteBtn.className = 'btn-secondary';
                deleteBtn.type = 'button';
                deleteBtn.textContent = 'Delete';
                actions.insertBefore(deleteBtn, actions.firstChild);
            }

            deleteBtn.onclick = async () => {
                try {
                    await fetch(`/api/tasks/${editingTaskId}/`, {
                        method: 'DELETE',
                        headers: { 'X-CSRFToken': csrftoken },
                        credentials: 'same-origin'
                    });
                    closeModal();
                    await refreshDashboardData({ silent: true });
                } catch (e) {
                    formError.textContent = 'Failed to delete task';
                }
            };
        }

        // Validation and submit
        quickAddForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const title = taskTitle.value.trim();
            const date = taskDate.value;
            const hour = taskHour.value;
            const color = taskColor.value;
            const description = taskDescription.value.trim();
            const priority = taskPriorityField.value;
            const status = taskStatusField.value;

            // simple validation system
            if (!title) {
                formError.textContent = 'Title is required.';
                taskTitle.focus();
                return;
            }
            if (!date) {
                formError.textContent = 'Date is required.';
                taskDate.focus();
                return;
            }
            if (hour === "" || hour == null) {
                formError.textContent = 'Start hour is required.';
                taskHour.focus();
                return;
            }

            const payload = { title, date, hour, color, description, priority, status };

            try {
                if (editingTaskId) {
                    // Edit existing task
                    await fetch(`/api/tasks/${editingTaskId}/`, {
                        method: 'PATCH',
                        headers: { 
                            'Content-Type': 'application/json', 
                            'X-CSRFToken': csrftoken 
                        },
                        credentials: 'same-origin',
                        body: JSON.stringify(payload)
                    });
                } else {
                    
                    const limitCheckDate = new Date();
                    const tasks = await apiGetTasks(limitCheckDate.getFullYear(), limitCheckDate.getMonth() + 1);
                    const currentTasks = tasks.filter(t => (t.status || 'pending').toLowerCase() !== 'completed');

                    if (currentTasks.length >= 5) {
                        formError.textContent = 'You have too many current tasks! Consider completing some before adding more.';
                        return;
                    }
                  

                    await fetch('/api/tasks/', {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json', 
                            'X-CSRFToken': csrftoken 
                        },
                        credentials: 'same-origin',
                        body: JSON.stringify(payload)
                    });
                }

                editingTaskId = null; // reset edit mode
                closeModal();
                await refreshDashboardData({ silent: true });

            } catch (err) {
                console.error(err);
                formError.textContent = err.message || 'Failed to save task.';
            }
        });

        async function renderWeeklySummary(summaryData = null) {
            try {
                const s = summaryData ?? await apiWeeklySummary();
                wsRange.textContent = `${new Date(s.start).toLocaleDateString()} - ${new Date(s.end).toLocaleDateString()}`;
                wsTotal.textContent = s.total;
                wsCompleted.textContent = s.completed;
                wsPending.textContent = s.pending;
                if (wsWarningBanner) {
                    const showWarning = Boolean(s.overload_warning);
                    wsWarningBanner.classList.toggle('hidden', !showWarning);
                    wsWarningBanner.setAttribute('aria-hidden', showWarning ? 'false' : 'true');
                }
            } catch (e) {
                wsRange.textContent = '—';
                wsTotal.textContent = '0';
                wsCompleted.textContent = '0';
                wsPending.textContent = '0';
                if (wsWarningBanner) {
                    wsWarningBanner.classList.add('hidden');
                    wsWarningBanner.setAttribute('aria-hidden', 'true');
                }
            }
        }

        async function renderCompletionStats(statsData = null) {
            try {
                const data = statsData ?? await apiWeeklyCompletionStats();
                const completed = data.completed_count || 0;
                const overdue = data.overdue_count || 0;
                const unfinished = data.unfinished_count || 0;
                const total = completed + overdue + unfinished;

                const completedPercent = total ? (completed / total) * 100 : 0;
                const overduePercent = total ? (overdue / total) * 100 : 0;
                const unfinishedPercent = total ? (unfinished / total) * 100 : 0;

                if (completedPctLabel) completedPctLabel.textContent = Math.round(completedPercent) + '%';
                if (overduePctLabel) overduePctLabel.textContent = Math.round(overduePercent) + '%';
                if (unfinishedPctLabel) unfinishedPctLabel.textContent = Math.round(unfinishedPercent) + '%';

                updateCompletionCircle(completedPercent, overduePercent, unfinishedPercent);
            } catch (err) {
                console.error(err);
                if (completedPctLabel) completedPctLabel.textContent = '0%';
                if (overduePctLabel) overduePctLabel.textContent = '0%';
                if (unfinishedPctLabel) unfinishedPctLabel.textContent = '0%';
                updateCompletionCircle(0, 0, 0);
            }
        }

        function updateCompletionCircle(completedPercent, overduePercent, unfinishedPercent) {
            if (!completionCircle) return;
            completionCircle.textContent = Math.round(completedPercent) + '%';
            completionCircle.setAttribute('aria-label', `Completed ${Math.round(completedPercent)} percent`);
            const hasProgress = completedPercent + overduePercent + unfinishedPercent > 0;
            completionCircle.style.background = hasProgress
                ? `
                    conic-gradient(
                        #0ab913 0% ${completedPercent}%,
                        #ffb3b3 ${completedPercent}% ${completedPercent + overduePercent}%,
                        #ffed9c ${completedPercent + overduePercent}% 100%
                    )
                  `
                : '#e2e8f0';
        }

        async function refreshDashboardData({ silent = false } = {}) {
            if (isRefreshing) return;
            isRefreshing = true;
            if (!silent) setAnalyticsStatus('Syncing latest data…', 'info');
            toggleRefresh(true);

            try {
                const year = now.getFullYear();
                const monthParam = now.getMonth() + 1;
                const [tasks, summary, completion] = await Promise.all([
                    apiGetTasks(year, monthParam),
                    apiWeeklySummary(),
                    apiWeeklyCompletionStats()
                ]);
                tasksCache = tasks;
                summaryCache = summary;
                completionCache = completion;

                await renderTasks(tasksCache);
                await renderWeeklySummary(summaryCache);
                await renderCompletionStats(completionCache);

                if (!silent) setAnalyticsStatus('Dashboard up to date', 'success');
            } catch (error) {
                console.error(error);
                setAnalyticsStatus('Unable to refresh dashboard', 'error');
            } finally {
                toggleRefresh(false);
                isRefreshing = false;
            }
        }

        if (refreshDashboardBtn) {
            refreshDashboardBtn.addEventListener('click', () => refreshDashboardData());
        }

        // Initial render
        refreshDashboardData();
    </script>
</body>
</html>
